//Во всех задачах из следующего списка следует написать структуру данных, обрабатывающую команды push* и pop*.
//Формат входных данных.
//В первой строке количество команд n.n ≤ 1000000.
//Каждая команда задаётся как 2 целых числа : a b.
//a = 1 - push front
//a = 2 - pop front
//a = 3 - push back
//a = 4 - pop back
//Для очереди используются команды 2 и 3. Для дека используются все четыре команды.
//Если дана команда pop*, то число b - ожидаемое значение.Если команда pop вызвана для пустой структуры данных, то ожидается “ - 1”.
//Формат выходных данных.
//Требуется напечатать YES - если все ожидаемые значения совпали.Иначе, если хотя бы одно ожидание не оправдалось, то напечатать NO.
//
//4_3.Реализовать очередь с помощью двух стеков.Использовать стек, реализованный с помощью динамического буфера.


#include <iostream>

///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
// Реализация ДИНАМИЧЕСКОГО МАССИВА ниже //
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////

// Константа, задающая начальный размер буфера
#define INITIAL_CAPACITY 4

// Объявление класса
class MyVector {
private:
	int size;     // текущий размер массива
	int capacity; // вместимость буфера
	int *data;    // указатель на буфер, где хранятся элементы

	void grow();  // функция увеличения размера буфера

public:
	MyVector();                       // конструктор
									  //MyVector(int _capacity);          // конструктор, принимающий параметр (вместимость)
									  //MyVector(const MyVector &other);  // конструктор копирования
	~MyVector();                      // деструктор

									  //MyVector& operator=(const MyVector &other); // оператор присваивания копированием

	void push_back(int val); // объявление функции добавления элемента
	int get_size() const;    // функция, возвращающая размер массива

	int& operator[](int i);      // оператор доступа к элементу по индексу
	int operator[](int i) const; // оператор доступа к элементу по индексу
								 // (константный, без возможности
								 // модифицирования данных, нужен, например,
								 // для функции print_vector)

	void push_on_position(int val, int position);
};

// Реализация конструктора
MyVector::MyVector()
	: size(0),
	capacity(INITIAL_CAPACITY)
{

	data = new int[capacity];
}

//// Реализация конструктора с параметром
//MyVector::MyVector(int _capacity)
//{
//
//	size = 0;
//	capacity = _capacity;
//	data = new int[capacity];
//}

//// Реализация конструктора копирования
//MyVector::MyVector(const MyVector &other)
//{
//
//	size = other.size;
//	capacity = other.capacity;
//	data = new int[capacity];
//	for (int i = 0; i < size; ++i)
//		data[i] = other.data[i];
//}

// Реализация деструктора
MyVector::~MyVector()
{

	delete[] data;
}

//// Реализация оператора присваивания копированием
//MyVector& MyVector::operator=(const MyVector &other)
//{
//
//	if (capacity < other.size)
//	{
//		delete[] data;
//
//		capacity = other.capacity;
//		data = new int[capacity];
//	}
//
//	size = other.size;
//	for (int i = 0; i < size; ++i)
//		data[i] = other.data[i];
//
//	return *this;
//}

// Реализация функции увеличения размера
void MyVector::grow()
{
	int new_capacity = capacity * 2;         // вычисляем размер нового буфера
	int *new_buffer = new int[new_capacity]; // выделяем новый буфер
	for (int i = 0; i < size; ++i)           // копируем данные в новый буфер
		new_buffer[i] = data[i];
	delete[] data;                           // удаляем старый буфер
	data = new_buffer;                       // заменяем указатель на буфер новым
	capacity = new_capacity;                 // обновляем вместимость
}

// Реализация функции добавления элемента в конец массива
void MyVector::push_back(int val)
{
	if (size + 1 > capacity)
		grow();

	data[size] = val;
	size++;
}

void MyVector::push_on_position(int val, int position)
{
	if (size + 1 > capacity)
		grow();

	data[position] = val;

	if (position == size)
		size++;
}

// Реализация функции получения размера вектора
int MyVector::get_size() const
{
	return size;
}

// Реализация оператора доступа к элементу
int& MyVector::operator[](int i)
{
	return data[i];
}

// Реализация константного оператора доступа к элементу
int MyVector::operator[](int i) const
{
	return data[i];
}

///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
////////// Реализация СТЕКА ниже //////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////

class CStack {

private:

	MyVector StackVector;
	int StackName; ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// NEWLINE
	int top; // Индекс верхнего элемента.

public:

	CStack() :		// Конструктор
		top(-1)
	{
		//MyVector StackVector();
		top = -1;
	}

	void Push(int T)
	{
		top++;
		StackVector.push_on_position(T, top);
	}

	int Pop()
	{

		if (top > -1)
		{
			int temp = StackVector[top];
			top--;
			return temp;
		}
		else
		{
			return -1;
		}

	}

	bool IsEmpty()
	{
		return top == -1;			// Проверка на пустоту
	}

};

///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
/////////// FINALLY... очередь ////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////

class queue
{
private:
	CStack top;
	CStack tail;

public:
	void enqueue(int x) {
		tail.Push(x);
	}

	void q_transform() {
		if (top.IsEmpty()) {
			while (!tail.IsEmpty())
			top.Push(tail.Pop());
		}
	}

	int dequeue() {
		q_transform();
		int temp = top.Pop();

		return temp;
	}

};

///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
////////// Реализация СТЕКА ниже //////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////
///////////////////////////////////////////

bool SolvingFunction(int n, int *InputArray)	// Функция с решением
{
	int i = 0;

	bool IsAllValuesMatches = 1;

	int Temp1 = 0, Temp2 = 0;

	queue SolvingQueue;

	for (i = 0; i < n; i++)
	{

		if (InputArray[2 * i] == 2)
		{
			int a = SolvingQueue.dequeue();

			if (a != InputArray[2 * i + 1])
			{
				IsAllValuesMatches = 0;
			}
		}
		else
		{
			SolvingQueue.enqueue(InputArray[2 * i + 1]);
		}

	}

	return IsAllValuesMatches;
}

int main()
{
	int n;									// Инициализация n - количество команд
	std::cin >> n;
	int *InputArray = new int[2 * n];			// Создание массива для ввода данных

	int i = 0;								// Инициализация массива
	for (i = 0; i < 2 * n; i++)				// значениями команд и
	{										// ожидаемого результата;
		std::cin >> InputArray[i];			// Команда идет под номером: k+1
	}										// Ожидаемое значение под:	 k+2

	int IsItRight = 0;									// Переменная для вывода ответа
	IsItRight = SolvingFunction(n, InputArray);			// Функция с решением

	if (IsItRight == 0)						// Вывод
	{
		std::cout << "NO";
	}
	else
	{
		std::cout << "YES";
	}


	delete[] InputArray;

	return 0;
}